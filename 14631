#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

/*다이나믹 프로그래밍(문제를 작게 나눠서 과거에 구한 해를 이용한다)
for문을 이용해서 bottom-up방식을 사용한다.
가장 작은 문제들부터 답을 구해가면서 답을 찾는 방식이다.*/

int main() {
	int x = 0;
	cin >> x;
	/*실행 횟수를 넣을 벡터
	벡터의 인덱스 값이 i번째 숫자를 구하는데 최소의 실행 횟수이다.*/
	vector<int> v(x+1);

	v[1] = 0;
	/*x에서 값을 나눠서 구하는 게 아니라 i부터 시작해서 얼마나 적은 횟수로 x를 만들 수 있느냐를 구하면 된다.
	하나의 실행만을 해주는 게 아니라 가능한 모든 실행을 해서 제일 작은 값을 넣어주면 된다.*/
	for (int i = 2; i <= x; i++) {
		/*조건 3.
		* x가 2일 경우.
		* 조건 3에 의해 -1을 해주면 바로 1의 값이 나온다. 한 번의 실행을 해줬기 때문에 v[2] = 1이 된다.
		* 그렇기에 1의 실행 값에다가 1을 더해서 v[2]의 실행값을 찾으면 된다. */
		v[i] = v[i - 1] + 1;

		/*조건 2.
		* x가 4일 경우.
		* 4, 4/2=2. 2-1=1.
		* 이렇게 두 개가 최적이다.
		* 조건 3을 돌렸을 때는 v[2] = v[1]+1, v[2] = 1이다.
		* i가 2로 나눠떨어지니 v[2] = min(v[i], v[i/2]+1)로 v[2]는 값이 1이 유지된다.
		* i가 3일 때는 조건 3에 의해 v[3] = v[2] + 1, v[3] = 2. 조건 1에 의해 min(v[3], v[3/3]+1), v[3] = 2.
		* i가 4일 대는 조건 3에 의해 v[4] = v[3] + 1, v[4] = 3. 조건 2에 의해 min(v[4], v[4/2]+1), v[4] = 2.
		* v[i/2]의 값을 찾는 이유는 x가 2로 나눠떨어지면 2로 나눈다고 했기에 2로 나눴던 값(i)의 횟수를 찾아서 더해주는 것이다.
		* 현재의 i는 i/2에서 2를 곱한 값이다.
		* 여기서 핵심은 i를 x로 만들 때까지 몇 번의 실행결과가 걸리냐로 돌리는 거다.*/
		if (i % 2 == 0) {
			v[i] = min(v[i], v[i / 2] + 1);
		}
		/*조건 1.
		조건 2와 동일하다.*/
		if (i % 3 == 0) {
			v[i] = min(v[i], v[i / 3] + 1);
		}
	}

	/*x라는 값을 구하기까지의 최소의 실행 횟수를 출력해준다.*/
	cout << v[x] << '\n';

	return 0;
}
